<!-- filename: index.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>shag.lol üòÅ bounce</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      /* Center the initial emoji; after spawn we still keep things simple */
      :root {
        color-scheme: light dark;
      }
      html, body {
        height: 100%;
        margin: 0;
      }
      body {
        display: grid;
        place-items: center;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: Canvas;
        color: CanvasText;
        overflow: hidden; /* prevent scroll while bouncing */
      }
      #canvas {
        position: fixed;
        inset: 0; /* full viewport for bouncing area */
        pointer-events: none; /* allow clicks to pass to the main emoji initially */
      }
      .emoji {
        position: absolute;
        font-size: 32px;          /* size of spawned emojis */
        line-height: 1;
        user-select: none;
        will-change: transform;   /* hint for smoother animation */
      }
      #starter {
        font-size: 96px;          /* large initial emoji in the center */
        cursor: pointer;
        user-select: none;
        z-index: 10;
      }
      #hint {
        position: fixed;
        bottom: 12px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 14px;
        opacity: 0.7;
        pointer-events: none;
      }
      @media (prefers-reduced-motion: reduce) {
        /* Respect users who prefer less motion: we won‚Äôt animate */
        .emoji {
          transition: none !important;
        }
      }
    </style>
  </head>
  <body>
    <!-- Initial clickable emoji -->
    <div id="starter" aria-label="Spawn bouncing emojis" role="button" tabindex="0">üòÅ</div>

    <!-- Layer where bouncing emoji elements live -->
    <div id="canvas" aria-hidden="true"></div>

    <div id="hint">Click the üòÅ to spawn 100 and watch them bounce</div>

    <script>
      // Configuration
      const COUNT = 100;          // how many emojis to spawn
      const SIZE = 32;            // px size; matches .emoji font-size
      const MIN_SPEED = 100;      // px per second
      const MAX_SPEED = 300;      // px per second

      // State
      const emojis = [];          // { el, x, y, vx, vy, size }
      let rafId = null;
      let lastTs = null;
      let bounds = { w: window.innerWidth, h: window.innerHeight };
      let running = false;

      const starter = document.getElementById('starter');
      const canvas = document.getElementById('canvas');

      // Utility: random in [min, max]
      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      // Create one emoji at random position with random velocity
      function createEmoji() {
        const el = document.createElement('div');
        el.className = 'emoji';
        el.textContent = 'üòÅ';

        // Random position within bounds (leave inside the viewport)
        const x = rand(0, Math.max(0, bounds.w - SIZE));
        const y = rand(0, Math.max(0, bounds.h - SIZE));

        // Random direction and speed
        const angle = rand(0, Math.PI * 2);
        const speed = rand(MIN_SPEED, MAX_SPEED);
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;

        // Mount
        canvas.appendChild(el);

        // Initial paint
        el.style.transform = `translate(${x}px, ${y}px)`;

        return { el, x, y, vx, vy, size: SIZE };
      }

      // Spawn COUNT emojis
      function spawn() {
        // If motion is reduced, show static grid (accessibility)
        const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        for (let i = 0; i < COUNT; i++) {
          const e = createEmoji();
          emojis.push(e);

          if (prefersReduced) {
            // Arrange in a simple grid if reduced motion is requested
            const cols = Math.max(1, Math.floor(bounds.w / (SIZE + 8)));
            const row = Math.floor(i / cols);
            const col = i % cols;
            e.x = col * (SIZE + 8) + 8;
            e.y = row * (SIZE + 8) + 8;
            e.vx = 0;
            e.vy = 0;
            e.el.style.transform = `translate(${e.x}px, ${e.y}px)`;
          }
        }

        // Start animation unless reduced motion
        if (!prefersReduced) start();
      }

      // Animation loop
      function start() {
        if (running) return;
        running = true;
        lastTs = performance.now();
        rafId = requestAnimationFrame(tick);
      }

      function stop() {
        running = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      function tick(ts) {
        const dt = Math.min(0.05, (ts - lastTs) / 1000); // clamp delta to 50ms to avoid huge jumps on tab switch
        lastTs = ts;

        const w = bounds.w;
        const h = bounds.h;

        for (const e of emojis) {
          // Integrate position
          e.x += e.vx * dt;
          e.y += e.vy * dt;

          // Bounce off walls; keep inside bounds
          if (e.x <= 0) { e.x = 0; e.vx = Math.abs(e.vx); }
          if (e.x + e.size >= w) { e.x = w - e.size; e.vx = -Math.abs(e.vx); }
          if (e.y <= 0) { e.y = 0; e.vy = Math.abs(e.vy); }
          if (e.y + e.size >= h) { e.y = h - e.size; e.vy = -Math.abs(e.vy); }

          // Apply transform
          e.el.style.transform = `translate(${e.x}px, ${e.y}px)`;
        }

        rafId = requestAnimationFrame(tick);
      }

      // Handle viewport resize
      function onResize() {
        bounds.w = window.innerWidth;
        bounds.h = window.innerHeight;

        // Ensure emojis remain inside after resize
        for (const e of emojis) {
          e.x = Math.min(Math.max(0, e.x), Math.max(0, bounds.w - e.size));
          e.y = Math.min(Math.max(0, e.y), Math.max(0, bounds.h - e.size));
          e.el.style.transform = `translate(${e.x}px, ${e.y}px)`;
        }
      }

      window.addEventListener('resize', onResize);

      // Click or keyboard activation on the starter emoji
      function activate() {
        // Remove hint, allow clicks to pass through bouncing layer
        document.getElementById('hint')?.remove();

        // After first click, we can let the canvas ignore pointer events
        canvas.style.pointerEvents = 'none';

        // Hide the big starter (optional: keep visible)
        starter.style.display = 'none';

        spawn();
      }

      starter.addEventListener('click', activate);
      starter.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          activate();
        }
      });

      // Optional: click anywhere to add more emojis
      document.addEventListener('click', (e) => {
        // If starter is visible, let its handler run
        if (starter.style.display !== 'none') return;
        // Add a small burst at click position
        const burst = 10;
        for (let i = 0; i < burst; i++) {
          const obj = createEmoji();
          obj.x = (e.clientX || bounds.w / 2) - SIZE / 2;
          obj.y = (e.clientY || bounds.h / 2) - SIZE / 2;
          emojis.push(obj);
        }
        // ensure animation is running
        if (!running && !window.matchMedia('(prefers-reduced-motion: reduce)').matches) start();
      });

      // Clean up on page hide (battery-friendly)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) stop();
        else if (emojis.length && !window.matchMedia('(prefers-reduced-motion: reduce)').matches) start();
      });
    </script>
  </body>
</html>
